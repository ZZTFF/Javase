package com.hspedu.poly.detail;
//多态就是父类的多态，父类可以是任何一个子类，但子类之间（无继承关系）则无法多态

//多态的前提，两个对象（类）存在继承关系
//多态的向上转型调用方法的规则
//本质：父类（可以是更高等的父类）的引用指向了子类的对象，（可以跨级引用）
//语法：父类类型 引用名 = new 子类类型();
//特点： 可以调用父类中所有成员(包括属性和方法)（需遵守访问权限），不能调用子类中特有成员，
// ，具体运行效果看子类的具体实现
public class PolyDetail {
    public static void main(String[] args) {
//        Animal animal = new Cat("狸花猫");
        Cat cat1 = new Cat("狸花猫");
        Animal animal = cat1;//此时cat1 == animal，因为都指向一个cat对象
//      老师说：可以调用父类除了private所有的方法和属性，不能调用子类的任何方法和任何属性
//      这是因为在编译阶段，能调用哪些成员是编译类型决定的

//      理解：也就是在idea打出animal.  idea只会提示给出父类除了private的属性和方法，无法给出子类的属性和方法，
//        但实际上是可以调用的，当把子类方法和父类用相同的方法名时，实际上还是遵从对象普通的调用方法方式，即从自己依次往父类找
        animal.say();
        animal.sayProtected();
        animal.sayPublic();

//希望可以.animal就可以看到子类的特有方法
//多态的向下转型
//语法：子类类型 引用名 = （子类类型） 父类引用；强制转换的意思
//只能强转父类的引用。不能强转父类的对象
//要求父类的引用必须指向的是当前目标类型的对象,也就是父类引用必须先进行向上转型，才能进行向下转型
//当向下转型后，可以调用子类类型中所有的成员

//      此时cat的编译类型，很明显，从定义上看，cat的编译类型是Cat，运行类型得看new Cat("狸花猫");实际上还是Cat
        Cat cat = (Cat) animal;
//        因此可以cat.调出子类的方法，无法访问子类私有方法，
//        此时对于父类中和子类同名的方法则无法调用，因为得首先在子类中查找方法，
//        且对于同名方法，子类不能降低访问权限
        cat.sayCat();
        cat.sayProtectedCat();
        cat.sayPublicCat();
    }
}




